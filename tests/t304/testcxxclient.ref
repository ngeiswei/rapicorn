// --- Generated by AidaCxxStub ---
#ifndef __CLNT__tests_t301_testpass_idl
#define __CLNT__tests_t301_testpass_idl


// --- ClientHH Boilerplate ---
#include <rapicorn-core.hh>

#define RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ(Enum)   \
  bool constexpr operator== (Enum v, int64_t n) { return int64_t (v) == n; } \
  bool constexpr operator== (int64_t n, Enum v) { return n == int64_t (v); } \
  bool constexpr operator!= (Enum v, int64_t n) { return int64_t (v) != n; } \
  bool constexpr operator!= (int64_t n, Enum v) { return n != int64_t (v); }
#define RAPICORN_AIDA_FLAGS_DEFINE_ARITHMETIC_OPS(Enum)   \
  static constexpr int64_t operator>> (Enum v, int64_t n) { return int64_t (v) >> n; } \
  static constexpr int64_t operator<< (Enum v, int64_t n) { return int64_t (v) << n; } \
  static constexpr int64_t operator^  (Enum v, int64_t n) { return int64_t (v) ^ n; } \
  static constexpr int64_t operator^  (int64_t n, Enum v) { return n ^ int64_t (v); } \
  static constexpr Enum    operator^  (Enum v, Enum w)    { return Enum (int64_t (v) ^ w); } \
  static constexpr int64_t operator|  (Enum v, int64_t n) { return int64_t (v) | n; } \
  static constexpr int64_t operator|  (int64_t n, Enum v) { return n | int64_t (v); } \
  static constexpr Enum    operator|  (Enum v, Enum w)    { return Enum (int64_t (v) | w); } \
  static constexpr int64_t operator&  (Enum v, int64_t n) { return int64_t (v) & n; } \
  static constexpr int64_t operator&  (int64_t n, Enum v) { return n & int64_t (v); } \
  static constexpr Enum    operator&  (Enum v, Enum w)    { return Enum (int64_t (v) & w); } \
  static constexpr int64_t operator~  (Enum v)            { return ~int64_t (v); } \
  static constexpr int64_t operator+  (Enum v)            { return +int64_t (v); } \
  static constexpr int64_t operator-  (Enum v)            { return -int64_t (v); } \
  static constexpr int64_t operator+  (Enum v, int64_t n) { return int64_t (v) + n; } \
  static constexpr int64_t operator+  (int64_t n, Enum v) { return n + int64_t (v); } \
  static constexpr int64_t operator-  (Enum v, int64_t n) { return int64_t (v) - n; } \
  static constexpr int64_t operator-  (int64_t n, Enum v) { return n - int64_t (v); } \
  static constexpr int64_t operator*  (Enum v, int64_t n) { return int64_t (v) * n; } \
  static constexpr int64_t operator*  (int64_t n, Enum v) { return n * int64_t (v); } \
  static constexpr int64_t operator/  (Enum v, int64_t n) { return int64_t (v) / n; } \
  static constexpr int64_t operator/  (int64_t n, Enum v) { return n / int64_t (v); } \
  static constexpr int64_t operator%  (Enum v, int64_t n) { return int64_t (v) % n; } \
  static constexpr int64_t operator%  (int64_t n, Enum v) { return n % int64_t (v); } \
  RAPICORN_FIXCYTHON_ENUM (Enum)
#ifdef     CYTHON_COMPILING_IN_CPYTHON
// Use C++ ADL, so PyInt_FromLong as generated by Cython works on scoped enums.
#define RAPICORN_FIXCYTHON_ENUM(Enum) \
  extern inline PyObject* PyInt_FromLong (Enum __e_) { return ::PyInt_FromLong (long (__e_)); }
#else  // !CYTHON_COMPILING_IN_CPYTHON
#define RAPICORN_FIXCYTHON_ENUM(Enum)
#endif // !CYTHON_COMPILING_IN_CPYTHON
#ifdef     RAPICORN_AIDA_ENABLE_ENUM_ARITHMETIC
#define RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS        RAPICORN_AIDA_FLAGS_DEFINE_ARITHMETIC_OPS
#else  // !RAPICORN_AIDA_ENABLE_ENUM_ARITHMETIC
#define RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS(Enum)  /* no arithmetic ops */
#endif // !RAPICORN_AIDA_ENABLE_ENUM_ARITHMETIC

#ifndef __AIDA_CXXSTUB_CLIENT_CC__
#define __AIDA_CXXSTUB_CLIENT_CC__

#ifndef AIDA_CHECK
#define AIDA_CHECK(cond,errmsg) do { if (cond) break; Rapicorn::Aida::fatal_error (__FILE__, __LINE__, errmsg); } while (0)
#endif

namespace { // Anon
using Rapicorn::Aida::uint64;

namespace __AIDA_Local__ {
using namespace Rapicorn::Aida;

// helper
static inline ProtoMsg*
new_emit_result (const ProtoMsg *fb, uint64 h, uint64 l, uint32 n)
{
  return ProtoMsg::renew_into_result (const_cast<ProtoMsg*> (fb), Rapicorn::Aida::MSGID_EMIT_RESULT, h, l, n);
}

} } // Anon::__AIDA_Local__

#endif // __AIDA_CXXSTUB_CLIENT_CC__


#ifndef __ENUMHH__tests_t301_testpass_idl__
#define __ENUMHH__tests_t301_testpass_idl__

namespace MandatoryNamespace {

/// @cond GeneratedEnums
enum class Enum1 : int64_t {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum1  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum1 &e) { e = Enum1 (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum1);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum1);
/// @endcond

/// @cond GeneratedEnums
enum class Enum1c : int64_t {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum1c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum1c &e) { e = Enum1c (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum1c);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum1c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum2 : int64_t {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum2  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum2 &e) { e = Enum2 (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum2);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum2);
/// @endcond

/// @cond GeneratedEnums
enum class Enum2c : int64_t {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum2c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum2c &e) { e = Enum2c (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum2c);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum2c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum3 : int64_t {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum3  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum3 &e) { e = Enum3 (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum3);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum3);
/// @endcond

/// @cond GeneratedEnums
enum class Enum3c : int64_t {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum3c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum3c &e) { e = Enum3c (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum3c);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum3c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4a : int64_t {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4a  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4a &e) { e = Enum4a (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4a);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4a);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4b : int64_t {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4b  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4b &e) { e = Enum4b (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4b);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4b);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4c : int64_t {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4c &e) { e = Enum4c (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4c);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4d : int64_t {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4d  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4d &e) { e = Enum4d (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4d);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4d);
/// @endcond

/// @cond GeneratedEnums
enum class ExtensiveEnum : int64_t {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = (-9223372036854775807 - 1),
  V26 = 9223372036854775807,
  V27 = 9223372036854775807,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  ExtensiveEnum  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, ExtensiveEnum &e) { e = ExtensiveEnum (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (ExtensiveEnum);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (ExtensiveEnum);
/// @endcond
} // MandatoryNamespace

namespace InterfaceTests {

/// @cond GeneratedEnums
enum class QuickEnum : int64_t {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  QuickEnum  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, QuickEnum &e) { e = QuickEnum (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (QuickEnum);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (QuickEnum);
/// @endcond
} // InterfaceTests

namespace RapicornAidaTest {

/// @cond GeneratedEnums
enum class ClickType : int64_t {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  ClickType  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, ClickType &e) { e = ClickType (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (ClickType);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (ClickType);
/// @endcond

/// @cond GeneratedEnums
enum class MathExpressions : int64_t {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  MathExpressions  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, MathExpressions &e) { e = MathExpressions (__f_.pop_evalue()); }
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_EQ (MathExpressions);
RAPICORN_AIDA_ENUM_DEFINE_ARITHMETIC_OPS (MathExpressions);
/// @endcond
} // RapicornAidaTest

namespace Rapicorn {

namespace Aida {
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum1> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum1c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum2> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum2c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum3> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum3c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4a> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4b> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4d> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::ExtensiveEnum> ();
template<> const EnumInfo& enum_info<InterfaceTests::QuickEnum> ();
template<> const EnumInfo& enum_info<RapicornAidaTest::ClickType> ();
template<> const EnumInfo& enum_info<RapicornAidaTest::MathExpressions> ();
} // Aida
} // Rapicorn

#endif // __ENUMHH__tests_t301_testpass_idl__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

/** @interface FirstInterface
 * See also the corresponding C++ stub class FirstInterfaceHandle. */
/// See also the corresponding IDL class FirstInterface.
class FirstInterfaceHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static FirstInterfaceHandle            __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~FirstInterfaceHandle () override;
  template<class RemoteHandle>
  static FirstInterfaceHandle   down_cast (RemoteHandle smh) { return smh == NULL ? FirstInterfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      FirstInterfaceHandle ();
  void                          void_func            (); 	///< See FirstInterface::void_func()
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef FirstInterfaceHandle FirstInterfaceH; ///< Convenience alias for the IDL type FirstInterface.

class ClnT_XFooRecord
{
public:
  /// @cond GeneratedFields
  bool                          single_bool;
  int                           single_num;
  int64_t                       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  Rapicorn::Aida::RemoteMember<FirstInterfaceHandle> iface1;
  Rapicorn::Aida::RemoteMember<FirstInterfaceHandle> iface2;
  Rapicorn::Aida::RemoteMember<FirstInterfaceHandle> iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  /// @endcond
  inline                        ClnT_XFooRecord () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::XFooRecord"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_XFooRecord &other) const;
  bool                          operator!=  (const ClnT_XFooRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (single_bool, "single_bool");
    _visitor_ (single_num, "single_num");
    _visitor_ (num64, "num64");
    _visitor_ (single_float, "single_float");
    _visitor_ (single_string, "single_string");
    _visitor_ (sibling1, "sibling1");
    _visitor_ (sibling2, "sibling2");
    _visitor_ (multi1, "multi1");
    _visitor_ (multi2, "multi2");
    _visitor_ (multi3, "multi3");
    _visitor_ (multi4, "multi4");
    _visitor_ (enum_field, "enum_field");
    _visitor_ (iface1, "iface1");
    _visitor_ (iface2, "iface2");
    _visitor_ (iface3, "iface3");
    _visitor_ (any1, "any1");
    _visitor_ (any2, "any2");
    _visitor_ (any3, "any3");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_XFooRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_XFooRecord&);

class ClnT_XFooSequence : public std::vector<bool>
{
public:
  typedef std::vector<bool> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::XFooSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_XFooSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_XFooSequence&);

class ClnT_IntSequence : public std::vector<int>
{
public:
  typedef std::vector<int> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::IntSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_IntSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_IntSequence&);

class ClnT_FloatSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::FloatSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_FloatSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_FloatSequence&);

class ClnT_StringSequence : public std::vector<std::string>
{
public:
  typedef std::vector<std::string> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::StringSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_StringSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_StringSequence&);

class ClnT_ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
public:
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::ExtensiveEnumSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_ExtensiveEnumSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_ExtensiveEnumSequence&);

class ClnT_RecordSequence : public std::vector<ClnT_XFooRecord>
{
public:
  typedef std::vector<ClnT_XFooRecord> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::RecordSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_RecordSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_RecordSequence&);

class ClnT_SequenceSequence : public std::vector<ClnT_IntSequence>
{
public:
  typedef std::vector<ClnT_IntSequence> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::SequenceSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_SequenceSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_SequenceSequence&);

class ClnT_InterfaceSequence : public std::vector<Rapicorn::Aida::RemoteMember<FirstInterfaceHandle>>
{
public:
  typedef std::vector<Rapicorn::Aida::RemoteMember<FirstInterfaceHandle>> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::InterfaceSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_InterfaceSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_InterfaceSequence&);

class ClnT_AnySequence : public std::vector<Rapicorn::Aida::Any>
{
public:
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::AnySequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_AnySequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_AnySequence&);

class ClnT_NestedTypesRec;

class ClnT_NestedTypesSeq;

class ClnT_NestedTypesRec
{
public:
  /// @cond GeneratedFields
  ClnT_XFooRecord               rec;
  ClnT_XFooSequence             seq;
  /// @endcond
  inline                        ClnT_NestedTypesRec () { }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::NestedTypesRec"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_NestedTypesRec &other) const;
  bool                          operator!=  (const ClnT_NestedTypesRec &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (rec, "rec");
    _visitor_ (seq, "seq");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_NestedTypesRec&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_NestedTypesRec&);

class ClnT_NestedTypesSeq : public std::vector<ClnT_NestedTypesRec>
{
public:
  typedef std::vector<ClnT_NestedTypesRec> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::NestedTypesSeq"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_NestedTypesSeq&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_NestedTypesSeq&);

class ClnT_NewRecord
{
public:
  /// @cond GeneratedFields
  int                           i;
  Enum1                         enum1;
  ClnT_XFooSequence             xfs;
  ClnT_NestedTypesRec           ntr;
  /// @endcond
  inline                        ClnT_NewRecord () { i = 0; enum1 = Enum1 (0); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::NewRecord"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_NewRecord &other) const;
  bool                          operator!=  (const ClnT_NewRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (i, "i");
    _visitor_ (enum1, "enum1");
    _visitor_ (xfs, "xfs");
    _visitor_ (ntr, "ntr");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_NewRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_NewRecord&);

namespace Inner {

class ClnT_InnerRecord
{
public:
  /// @cond GeneratedFields
  int                           x;
  int                           y;
  ClnT_NewRecord                rec;
  /// @endcond
  inline                        ClnT_InnerRecord () { x = 0; y = 0; }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::Inner::InnerRecord"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_InnerRecord &other) const;
  bool                          operator!=  (const ClnT_InnerRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (x, "x");
    _visitor_ (y, "y");
    _visitor_ (rec, "rec");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_InnerRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_InnerRecord&);
} // Inner

class ClnT_Refer2Inner
{
public:
  /// @cond GeneratedFields
  Inner::ClnT_InnerRecord       r;
  /// @endcond
  inline                        ClnT_Refer2Inner () { }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::Refer2Inner"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_Refer2Inner &other) const;
  bool                          operator!=  (const ClnT_Refer2Inner &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (r, "r");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_Refer2Inner&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_Refer2Inner&);
} // MandatoryNamespace

namespace OtherNamespace {

class ClnT_SomeRecord
{
public:
  /// @cond GeneratedFields
  MandatoryNamespace::ClnT_NewRecord r1;
  MandatoryNamespace::ClnT_NewRecord r2;
  MandatoryNamespace::Inner::ClnT_InnerRecord r3;
  MandatoryNamespace::Inner::ClnT_InnerRecord r4;
  /// @endcond
  inline                        ClnT_SomeRecord () { }
  std::string                   __aida_type_name__ () const	{ return "OtherNamespace::SomeRecord"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_SomeRecord &other) const;
  bool                          operator!=  (const ClnT_SomeRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (r1, "r1");
    _visitor_ (r2, "r2");
    _visitor_ (r3, "r3");
    _visitor_ (r4, "r4");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_SomeRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_SomeRecord&);
} // OtherNamespace

namespace Auxdata {

class ClnT_RecordWithAuxdata
{
public:
  /// @cond GeneratedFields
  bool                          aux_bool;
  int                           aux32;
  int64_t                       aux64;
  double                        auxf64;
  std::string                   aux_str;
  /// @endcond
  inline                        ClnT_RecordWithAuxdata () { aux_bool = 0; aux32 = 0; aux64 = 0; auxf64 = 0; }
  std::string                   __aida_type_name__ () const	{ return "Auxdata::RecordWithAuxdata"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_RecordWithAuxdata &other) const;
  bool                          operator!=  (const ClnT_RecordWithAuxdata &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (aux_bool, "aux_bool");
    _visitor_ (aux32, "aux32");
    _visitor_ (aux64, "aux64");
    _visitor_ (auxf64, "auxf64");
    _visitor_ (aux_str, "aux_str");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_RecordWithAuxdata&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_RecordWithAuxdata&);
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ stub class UIWidgetAreaHandle. */
/// See also the corresponding IDL class UIWidgetArea.
class UIWidgetAreaHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  typedef Rapicorn::Aida::Connector<UIWidgetAreaHandle, void ()> __Aida_Signal__void_signal;
  size_t __aida_connect__void_signal (size_t, const std::function<void ()>&);
  typedef Rapicorn::Aida::Connector<UIWidgetAreaHandle, double (UIWidgetAreaHandle &ba1, int someint)> __Aida_Signal__sample_signal;
  size_t __aida_connect__sample_signal (size_t, const std::function<double (UIWidgetAreaHandle &ba1, int someint)>&);
  static UIWidgetAreaHandle              __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~UIWidgetAreaHandle () override;
  template<class RemoteHandle>
  static UIWidgetAreaHandle     down_cast (RemoteHandle smh) { return smh == NULL ? UIWidgetAreaHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      UIWidgetAreaHandle ();
  bool                          dummy    () const; 	///< See UIWidgetArea::dummy
  void                          dummy    (bool); 	///< See UIWidgetArea::dummy
  std::string                   on_click () const; 	///< See UIWidgetArea::on_click
  void                          on_click (const std::string&); 	///< See UIWidgetArea::on_click
  __Aida_Signal__void_signal    sig_void_signal () { return __Aida_Signal__void_signal (*this, &UIWidgetAreaHandle::__aida_connect__void_signal); }
  __Aida_Signal__sample_signal  sig_sample_signal () { return __Aida_Signal__sample_signal (*this, &UIWidgetAreaHandle::__aida_connect__sample_signal); }
  double                        simple_method      (); 	///< See UIWidgetArea::simple_method()
  double                        single_arg         (int n); 	///< See UIWidgetArea::single_arg()
  double                        single_arg2        (int n = 5); 	///< See UIWidgetArea::single_arg2()
  double                        two_args           (int n,
                                                    double r); 	///< See UIWidgetArea::two_args()
  double                        two_args2          (int n = 6,
                                                    double r = 7.7); 	///< See UIWidgetArea::two_args2()
  double                        multi_args         (bool b,
                                                    int64_t n,
                                                    double r,
                                                    int i,
                                                    const std::string &s = "String ding",
                                                    double y = 5); 	///< See UIWidgetArea::multi_args()
  double                        self_method        (UIWidgetAreaHandle &ba1,
                                                    UIWidgetAreaHandle &ba2); 	///< See UIWidgetArea::self_method()
  void                          void_method        (); 	///< See UIWidgetArea::void_method()
  std::string                   on_click2out       (); 	///< See UIWidgetArea::on_click2out()
  void                          on_click2in        (const std::string &command); 	///< See UIWidgetArea::on_click2in()
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "dummy", &UIWidgetAreaHandle::dummy, &UIWidgetAreaHandle::dummy);
    __visitor_ (*this, "on_click", &UIWidgetAreaHandle::on_click, &UIWidgetAreaHandle::on_click);
  }
};
typedef UIWidgetAreaHandle UIWidgetAreaH; ///< Convenience alias for the IDL type UIWidgetArea.

/** @interface Parent
 * See also the corresponding C++ stub class ParentHandle. */
/// See also the corresponding IDL class Parent.
class ParentHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static ParentHandle                    __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~ParentHandle () override;
  template<class RemoteHandle>
  static ParentHandle           down_cast (RemoteHandle smh) { return smh == NULL ? ParentHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ParentHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef ParentHandle ParentH; ///< Convenience alias for the IDL type Parent.

/** @interface Child
 * See also the corresponding C++ stub class ChildHandle. */
/// See also the corresponding IDL class Child.
class ChildHandle : public virtual ParentHandle
{
  static ChildHandle                     __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~ChildHandle () override;
  template<class RemoteHandle>
  static ChildHandle            down_cast (RemoteHandle smh) { return smh == NULL ? ChildHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ChildHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->ParentHandle::__accept_accessor__ (__visitor_);
  }
};
typedef ChildHandle ChildH; ///< Convenience alias for the IDL type Child.

/** @interface Descendant
 * See also the corresponding C++ stub class DescendantHandle. */
/// See also the corresponding IDL class Descendant.
class DescendantHandle : public virtual ChildHandle
{
  static DescendantHandle                __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~DescendantHandle () override;
  template<class RemoteHandle>
  static DescendantHandle       down_cast (RemoteHandle smh) { return smh == NULL ? DescendantHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      DescendantHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->ChildHandle::__accept_accessor__ (__visitor_);
  }
};
typedef DescendantHandle DescendantH; ///< Convenience alias for the IDL type Descendant.

/** @interface GrandChild
 * See also the corresponding C++ stub class GrandChildHandle. */
/// See also the corresponding IDL class GrandChild.
class GrandChildHandle : public virtual DescendantHandle
{
  static GrandChildHandle                __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~GrandChildHandle () override;
  template<class RemoteHandle>
  static GrandChildHandle       down_cast (RemoteHandle smh) { return smh == NULL ? GrandChildHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      GrandChildHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->DescendantHandle::__accept_accessor__ (__visitor_);
  }
};
typedef GrandChildHandle GrandChildH; ///< Convenience alias for the IDL type GrandChild.

class ClnT_QuickRecord
{
public:
  /// @cond GeneratedFields
  int                           int1;
  int                           int2;
  /// @endcond
  inline                        ClnT_QuickRecord () { int1 = 0; int2 = 0; }
  std::string                   __aida_type_name__ () const	{ return "InterfaceTests::QuickRecord"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_QuickRecord &other) const;
  bool                          operator!=  (const ClnT_QuickRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (int1, "int1");
    _visitor_ (int2, "int2");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_QuickRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_QuickRecord&);

class ClnT_QuickSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                   __aida_type_name__ () const	{ return "InterfaceTests::QuickSequence"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_QuickSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_QuickSequence&);

/** @interface QuickIface
 * See also the corresponding C++ stub class QuickIfaceHandle. */
/// See also the corresponding IDL class QuickIface.
class QuickIfaceHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static QuickIfaceHandle                __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~QuickIfaceHandle () override;
  template<class RemoteHandle>
  static QuickIfaceHandle       down_cast (RemoteHandle smh) { return smh == NULL ? QuickIfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      QuickIfaceHandle ();
  void                          simple_function  (int i = 9); 	///< See QuickIface::simple_function()
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef QuickIfaceHandle QuickIfaceH; ///< Convenience alias for the IDL type QuickIface.

/** @interface MethodTestInterface
 * See also the corresponding C++ stub class MethodTestInterfaceHandle. */
/// See also the corresponding IDL class MethodTestInterface.
class MethodTestInterfaceHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static MethodTestInterfaceHandle       __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~MethodTestInterfaceHandle () override;
  template<class RemoteHandle>
  static MethodTestInterfaceHandle down_cast (RemoteHandle smh) { return smh == NULL ? MethodTestInterfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      MethodTestInterfaceHandle ();
  void                          method_with_void          (); 	///< See MethodTestInterface::method_with_void()
  bool                          method_with_bools         (bool input,
                                                           bool optval = 0); 	///< See MethodTestInterface::method_with_bools()
  int                           method_with_ints32        (int input,
                                                           int optval = -2); 	///< See MethodTestInterface::method_with_ints32()
  int64_t                       method_with_ints64        (int64_t input,
                                                           int64_t optval = 576460752303423488); 	///< See MethodTestInterface::method_with_ints64()
  double                        method_with_floats        (double input,
                                                           double optval = 309.9); 	///< See MethodTestInterface::method_with_floats()
  std::string                   method_with_string        (const std::string &input,
                                                           const std::string &optval = "default"); 	///< See MethodTestInterface::method_with_string()
  QuickEnum                     method_with_enum          (QuickEnum input,
                                                           QuickEnum optval = QuickEnum (0)); 	///< See MethodTestInterface::method_with_enum()
  ClnT_QuickRecord              method_with_record        (const ClnT_QuickRecord &input,
                                                           const ClnT_QuickRecord &optval = ClnT_QuickRecord()); 	///< See MethodTestInterface::method_with_record()
  ClnT_QuickSequence            method_with_sequence      (const ClnT_QuickSequence &input,
                                                           const ClnT_QuickSequence &optval = ClnT_QuickSequence()); 	///< See MethodTestInterface::method_with_sequence()
  GrandChildHandle              method_with_interface     (GrandChildHandle &input,
                                                           GrandChildHandle &optval = *(GrandChildHandle*) NULL); 	///< See MethodTestInterface::method_with_interface()
  Rapicorn::Aida::Any           method_with_anys          (const Rapicorn::Aida::Any &input,
                                                           const Rapicorn::Aida::Any &optval); 	///< See MethodTestInterface::method_with_anys()
  QuickIfaceHandle              method_with_quickiface    (QuickIfaceHandle &input,
                                                           QuickIfaceHandle &iface0 = *(QuickIfaceHandle*) NULL); 	///< See MethodTestInterface::method_with_quickiface()
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef MethodTestInterfaceHandle MethodTestInterfaceH; ///< Convenience alias for the IDL type MethodTestInterface.

/** @interface SignalTestInterface
 * See also the corresponding C++ stub class SignalTestInterfaceHandle. */
/// See also the corresponding IDL class SignalTestInterface.
class SignalTestInterfaceHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void ()> __Aida_Signal__void_result;
  size_t __aida_connect__void_result (size_t, const std::function<void ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, bool ()> __Aida_Signal__bool_result;
  size_t __aida_connect__bool_result (size_t, const std::function<bool ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, int ()> __Aida_Signal__int32_result;
  size_t __aida_connect__int32_result (size_t, const std::function<int ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, int64_t ()> __Aida_Signal__int64_result;
  size_t __aida_connect__int64_result (size_t, const std::function<int64_t ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, double ()> __Aida_Signal__float64_result;
  size_t __aida_connect__float64_result (size_t, const std::function<double ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, std::string ()> __Aida_Signal__string_result;
  size_t __aida_connect__string_result (size_t, const std::function<std::string ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, QuickEnum ()> __Aida_Signal__enum_result;
  size_t __aida_connect__enum_result (size_t, const std::function<QuickEnum ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, ClnT_QuickRecord ()> __Aida_Signal__record_result;
  size_t __aida_connect__record_result (size_t, const std::function<ClnT_QuickRecord ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, ClnT_QuickSequence ()> __Aida_Signal__sequence_result;
  size_t __aida_connect__sequence_result (size_t, const std::function<ClnT_QuickSequence ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, GrandChildHandle ()> __Aida_Signal__interface_result;
  size_t __aida_connect__interface_result (size_t, const std::function<GrandChildHandle ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, Rapicorn::Aida::Any ()> __Aida_Signal__any_result;
  size_t __aida_connect__any_result (size_t, const std::function<Rapicorn::Aida::Any ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, SignalTestInterfaceHandle ()> __Aida_Signal__self_result;
  size_t __aida_connect__self_result (size_t, const std::function<SignalTestInterfaceHandle ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void ()> __Aida_Signal__void_arg;
  size_t __aida_connect__void_arg (size_t, const std::function<void ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (bool b)> __Aida_Signal__bool_arg;
  size_t __aida_connect__bool_arg (size_t, const std::function<void (bool b)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (int i)> __Aida_Signal__int32_arg;
  size_t __aida_connect__int32_arg (size_t, const std::function<void (int i)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (int64_t i)> __Aida_Signal__int64_arg;
  size_t __aida_connect__int64_arg (size_t, const std::function<void (int64_t i)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (double f)> __Aida_Signal__float64_arg;
  size_t __aida_connect__float64_arg (size_t, const std::function<void (double f)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const std::string &s)> __Aida_Signal__string_arg;
  size_t __aida_connect__string_arg (size_t, const std::function<void (const std::string &s)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (QuickEnum e)> __Aida_Signal__enum_arg;
  size_t __aida_connect__enum_arg (size_t, const std::function<void (QuickEnum e)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const ClnT_QuickRecord &r)> __Aida_Signal__record_arg;
  size_t __aida_connect__record_arg (size_t, const std::function<void (const ClnT_QuickRecord &r)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const ClnT_QuickSequence &s)> __Aida_Signal__sequence_arg;
  size_t __aida_connect__sequence_arg (size_t, const std::function<void (const ClnT_QuickSequence &s)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (GrandChildHandle &i)> __Aida_Signal__interface_arg;
  size_t __aida_connect__interface_arg (size_t, const std::function<void (GrandChildHandle &i)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const Rapicorn::Aida::Any &a)> __Aida_Signal__any_arg;
  size_t __aida_connect__any_arg (size_t, const std::function<void (const Rapicorn::Aida::Any &a)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (SignalTestInterfaceHandle &self_)> __Aida_Signal__self_args;
  size_t __aida_connect__self_args (size_t, const std::function<void (SignalTestInterfaceHandle &self_)>&);
  static SignalTestInterfaceHandle       __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~SignalTestInterfaceHandle () override;
  template<class RemoteHandle>
  static SignalTestInterfaceHandle down_cast (RemoteHandle smh) { return smh == NULL ? SignalTestInterfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      SignalTestInterfaceHandle ();
  __Aida_Signal__void_result    sig_void_result () { return __Aida_Signal__void_result (*this, &SignalTestInterfaceHandle::__aida_connect__void_result); }
  __Aida_Signal__bool_result    sig_bool_result () { return __Aida_Signal__bool_result (*this, &SignalTestInterfaceHandle::__aida_connect__bool_result); }
  __Aida_Signal__int32_result   sig_int32_result () { return __Aida_Signal__int32_result (*this, &SignalTestInterfaceHandle::__aida_connect__int32_result); }
  __Aida_Signal__int64_result   sig_int64_result () { return __Aida_Signal__int64_result (*this, &SignalTestInterfaceHandle::__aida_connect__int64_result); }
  __Aida_Signal__float64_result sig_float64_result () { return __Aida_Signal__float64_result (*this, &SignalTestInterfaceHandle::__aida_connect__float64_result); }
  __Aida_Signal__string_result  sig_string_result () { return __Aida_Signal__string_result (*this, &SignalTestInterfaceHandle::__aida_connect__string_result); }
  __Aida_Signal__enum_result    sig_enum_result () { return __Aida_Signal__enum_result (*this, &SignalTestInterfaceHandle::__aida_connect__enum_result); }
  __Aida_Signal__record_result  sig_record_result () { return __Aida_Signal__record_result (*this, &SignalTestInterfaceHandle::__aida_connect__record_result); }
  __Aida_Signal__sequence_result sig_sequence_result () { return __Aida_Signal__sequence_result (*this, &SignalTestInterfaceHandle::__aida_connect__sequence_result); }
  __Aida_Signal__interface_result sig_interface_result () { return __Aida_Signal__interface_result (*this, &SignalTestInterfaceHandle::__aida_connect__interface_result); }
  __Aida_Signal__any_result     sig_any_result () { return __Aida_Signal__any_result (*this, &SignalTestInterfaceHandle::__aida_connect__any_result); }
  __Aida_Signal__self_result    sig_self_result () { return __Aida_Signal__self_result (*this, &SignalTestInterfaceHandle::__aida_connect__self_result); }
  __Aida_Signal__void_arg       sig_void_arg () { return __Aida_Signal__void_arg (*this, &SignalTestInterfaceHandle::__aida_connect__void_arg); }
  __Aida_Signal__bool_arg       sig_bool_arg () { return __Aida_Signal__bool_arg (*this, &SignalTestInterfaceHandle::__aida_connect__bool_arg); }
  __Aida_Signal__int32_arg      sig_int32_arg () { return __Aida_Signal__int32_arg (*this, &SignalTestInterfaceHandle::__aida_connect__int32_arg); }
  __Aida_Signal__int64_arg      sig_int64_arg () { return __Aida_Signal__int64_arg (*this, &SignalTestInterfaceHandle::__aida_connect__int64_arg); }
  __Aida_Signal__float64_arg    sig_float64_arg () { return __Aida_Signal__float64_arg (*this, &SignalTestInterfaceHandle::__aida_connect__float64_arg); }
  __Aida_Signal__string_arg     sig_string_arg () { return __Aida_Signal__string_arg (*this, &SignalTestInterfaceHandle::__aida_connect__string_arg); }
  __Aida_Signal__enum_arg       sig_enum_arg () { return __Aida_Signal__enum_arg (*this, &SignalTestInterfaceHandle::__aida_connect__enum_arg); }
  __Aida_Signal__record_arg     sig_record_arg () { return __Aida_Signal__record_arg (*this, &SignalTestInterfaceHandle::__aida_connect__record_arg); }
  __Aida_Signal__sequence_arg   sig_sequence_arg () { return __Aida_Signal__sequence_arg (*this, &SignalTestInterfaceHandle::__aida_connect__sequence_arg); }
  __Aida_Signal__interface_arg  sig_interface_arg () { return __Aida_Signal__interface_arg (*this, &SignalTestInterfaceHandle::__aida_connect__interface_arg); }
  __Aida_Signal__any_arg        sig_any_arg () { return __Aida_Signal__any_arg (*this, &SignalTestInterfaceHandle::__aida_connect__any_arg); }
  __Aida_Signal__self_args      sig_self_args () { return __Aida_Signal__self_args (*this, &SignalTestInterfaceHandle::__aida_connect__self_args); }
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef SignalTestInterfaceHandle SignalTestInterfaceH; ///< Convenience alias for the IDL type SignalTestInterface.

/** @interface ChildInheritingSignals
 * See also the corresponding C++ stub class ChildInheritingSignalsHandle. */
/// See also the corresponding IDL class ChildInheritingSignals.
class ChildInheritingSignalsHandle : public virtual SignalTestInterfaceHandle
{
  typedef Rapicorn::Aida::Connector<ChildInheritingSignalsHandle, void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const ClnT_QuickRecord &r, const ClnT_QuickSequence &s)> __Aida_Signal__child_signal;
  size_t __aida_connect__child_signal (size_t, const std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const ClnT_QuickRecord &r, const ClnT_QuickSequence &s)>&);
  static ChildInheritingSignalsHandle    __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~ChildInheritingSignalsHandle () override;
  template<class RemoteHandle>
  static ChildInheritingSignalsHandle down_cast (RemoteHandle smh) { return smh == NULL ? ChildInheritingSignalsHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ChildInheritingSignalsHandle ();
  __Aida_Signal__child_signal   sig_child_signal () { return __Aida_Signal__child_signal (*this, &ChildInheritingSignalsHandle::__aida_connect__child_signal); }
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->SignalTestInterfaceHandle::__accept_accessor__ (__visitor_);
  }
};
typedef ChildInheritingSignalsHandle ChildInheritingSignalsH; ///< Convenience alias for the IDL type ChildInheritingSignals.

/** @interface AnotherChild
 * See also the corresponding C++ stub class AnotherChildHandle. */
/// See also the corresponding IDL class AnotherChild.
class AnotherChildHandle : public virtual SignalTestInterfaceHandle
{
  static AnotherChildHandle              __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~AnotherChildHandle () override;
  template<class RemoteHandle>
  static AnotherChildHandle     down_cast (RemoteHandle smh) { return smh == NULL ? AnotherChildHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      AnotherChildHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->SignalTestInterfaceHandle::__accept_accessor__ (__visitor_);
  }
};
typedef AnotherChildHandle AnotherChildH; ///< Convenience alias for the IDL type AnotherChild.

/** @interface PropertyTester
 * See also the corresponding C++ stub class PropertyTesterHandle. */
/// See also the corresponding IDL class PropertyTester.
class PropertyTesterHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static PropertyTesterHandle            __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~PropertyTesterHandle () override;
  template<class RemoteHandle>
  static PropertyTesterHandle   down_cast (RemoteHandle smh) { return smh == NULL ? PropertyTesterHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      PropertyTesterHandle ();
  bool                          bool_prop      () const; 	///< See PropertyTester::bool_prop
  void                          bool_prop      (bool); 	///< See PropertyTester::bool_prop
  int                           int32_prop     () const; 	///< See PropertyTester::int32_prop
  void                          int32_prop     (int); 	///< See PropertyTester::int32_prop
  int64_t                       int64_prop     () const; 	///< See PropertyTester::int64_prop
  void                          int64_prop     (int64_t); 	///< See PropertyTester::int64_prop
  double                        float64_prop   () const; 	///< See PropertyTester::float64_prop
  void                          float64_prop   (double); 	///< See PropertyTester::float64_prop
  std::string                   string_prop    () const; 	///< See PropertyTester::string_prop
  void                          string_prop    (const std::string&); 	///< See PropertyTester::string_prop
  QuickEnum                     enum_prop      () const; 	///< See PropertyTester::enum_prop
  void                          enum_prop      (QuickEnum); 	///< See PropertyTester::enum_prop
  ClnT_QuickRecord              record_prop    () const; 	///< See PropertyTester::record_prop
  void                          record_prop    (const ClnT_QuickRecord&); 	///< See PropertyTester::record_prop
  ClnT_QuickSequence            sequence_prop  () const; 	///< See PropertyTester::sequence_prop
  void                          sequence_prop  (const ClnT_QuickSequence&); 	///< See PropertyTester::sequence_prop
  GrandChildHandle              interface_prop () const; 	///< See PropertyTester::interface_prop
  void                          interface_prop (GrandChildHandle); 	///< See PropertyTester::interface_prop
  PropertyTesterHandle          self_prop      () const; 	///< See PropertyTester::self_prop
  void                          self_prop      (PropertyTesterHandle); 	///< See PropertyTester::self_prop
  Rapicorn::Aida::Any           any_prop       () const; 	///< See PropertyTester::any_prop
  void                          any_prop       (const Rapicorn::Aida::Any&); 	///< See PropertyTester::any_prop
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "bool_prop", &PropertyTesterHandle::bool_prop, &PropertyTesterHandle::bool_prop);
    __visitor_ (*this, "int32_prop", &PropertyTesterHandle::int32_prop, &PropertyTesterHandle::int32_prop);
    __visitor_ (*this, "int64_prop", &PropertyTesterHandle::int64_prop, &PropertyTesterHandle::int64_prop);
    __visitor_ (*this, "float64_prop", &PropertyTesterHandle::float64_prop, &PropertyTesterHandle::float64_prop);
    __visitor_ (*this, "string_prop", &PropertyTesterHandle::string_prop, &PropertyTesterHandle::string_prop);
    __visitor_ (*this, "enum_prop", &PropertyTesterHandle::enum_prop, &PropertyTesterHandle::enum_prop);
    __visitor_ (*this, "record_prop", &PropertyTesterHandle::record_prop, &PropertyTesterHandle::record_prop);
    __visitor_ (*this, "sequence_prop", &PropertyTesterHandle::sequence_prop, &PropertyTesterHandle::sequence_prop);
    __visitor_ (*this, "interface_prop", &PropertyTesterHandle::interface_prop, &PropertyTesterHandle::interface_prop);
    __visitor_ (*this, "self_prop", &PropertyTesterHandle::self_prop, &PropertyTesterHandle::self_prop);
    __visitor_ (*this, "any_prop", &PropertyTesterHandle::any_prop, &PropertyTesterHandle::any_prop);
  }
};
typedef PropertyTesterHandle PropertyTesterH; ///< Convenience alias for the IDL type PropertyTester.
} // InterfaceTests

namespace RapicornAidaTest {

/** @interface UseIncludes
 * See also the corresponding C++ stub class UseIncludesHandle. */
/// See also the corresponding IDL class UseIncludes.
class UseIncludesHandle : public virtual IncludeCheck::SomeInterfaceHandle
{
  static UseIncludesHandle               __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~UseIncludesHandle () override;
  template<class RemoteHandle>
  static UseIncludesHandle      down_cast (RemoteHandle smh) { return smh == NULL ? UseIncludesHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      UseIncludesHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->IncludeCheck::SomeInterfaceHandle::__accept_accessor__ (__visitor_);
  }
};
typedef UseIncludesHandle UseIncludesH; ///< Convenience alias for the IDL type UseIncludes.

/** @interface ButtonArea
 * See also the corresponding C++ stub class ButtonAreaHandle. */
/// See also the corresponding IDL class ButtonArea.
class ButtonAreaHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  typedef Rapicorn::Aida::Connector<ButtonAreaHandle, bool ()> __Aida_Signal__check_activate;
  size_t __aida_connect__check_activate (size_t, const std::function<bool ()>&);
  typedef Rapicorn::Aida::Connector<ButtonAreaHandle, void ()> __Aida_Signal__activate;
  size_t __aida_connect__activate (size_t, const std::function<void ()>&);
  static ButtonAreaHandle                __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~ButtonAreaHandle () override;
  template<class RemoteHandle>
  static ButtonAreaHandle       down_cast (RemoteHandle smh) { return smh == NULL ? ButtonAreaHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ButtonAreaHandle ();
  std::string                   on_click   () const; 	///< See ButtonArea::on_click
  void                          on_click   (const std::string&); 	///< See ButtonArea::on_click
  std::string                   on_click2  () const; 	///< See ButtonArea::on_click2
  void                          on_click2  (const std::string&); 	///< See ButtonArea::on_click2
  std::string                   on_click3  () const; 	///< See ButtonArea::on_click3
  void                          on_click3  (const std::string&); 	///< See ButtonArea::on_click3
  ClickType                     click_type () const; 	///< See ButtonArea::click_type
  void                          click_type (ClickType); 	///< See ButtonArea::click_type
  __Aida_Signal__check_activate sig_check_activate () { return __Aida_Signal__check_activate (*this, &ButtonAreaHandle::__aida_connect__check_activate); }
  __Aida_Signal__activate       sig_activate () { return __Aida_Signal__activate (*this, &ButtonAreaHandle::__aida_connect__activate); }
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "on_click", &ButtonAreaHandle::on_click, &ButtonAreaHandle::on_click);
    __visitor_ (*this, "on_click2", &ButtonAreaHandle::on_click2, &ButtonAreaHandle::on_click2);
    __visitor_ (*this, "on_click3", &ButtonAreaHandle::on_click3, &ButtonAreaHandle::on_click3);
    __visitor_ (*this, "click_type", &ButtonAreaHandle::click_type, &ButtonAreaHandle::click_type);
  }
};
typedef ButtonAreaHandle ButtonAreaH; ///< Convenience alias for the IDL type ButtonArea.

class PureMethodsHandle;

/** @interface PureMethods
 * See also the corresponding C++ stub class PureMethodsHandle. */
/// See also the corresponding IDL class PureMethods.
class PureMethodsHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static PureMethodsHandle               __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~PureMethodsHandle () override;
  template<class RemoteHandle>
  static PureMethodsHandle      down_cast (RemoteHandle smh) { return smh == NULL ? PureMethodsHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      PureMethodsHandle ();
  int                           pure_method       (double f); 	///< See PureMethods::pure_method()
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef PureMethodsHandle PureMethodsH; ///< Convenience alias for the IDL type PureMethods.
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ stub class NameTestsHandle. */
/// See also the corresponding IDL class NameTests.
class NameTestsHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static NameTestsHandle                 __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~NameTestsHandle () override;
  template<class RemoteHandle>
  static NameTestsHandle        down_cast (RemoteHandle smh) { return smh == NULL ? NameTestsHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      NameTestsHandle ();
  void                          args_from_other_namespace (const InterfaceTests::ClnT_QuickRecord &qr,
                                                           RapicornAidaTest::ClickType qe,
                                                           const OtherNamespace::ClnT_SomeRecord &sr); 	///< See NameTests::args_from_other_namespace()
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef NameTestsHandle NameTestsH; ///< Convenience alias for the IDL type NameTests.
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ stub class CompressorHandle. */
/// See also the corresponding IDL class Compressor.
class CompressorHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static CompressorHandle                __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~CompressorHandle () override;
  template<class RemoteHandle>
  static CompressorHandle       down_cast (RemoteHandle smh) { return smh == NULL ? CompressorHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      CompressorHandle ();
  double                        threshold () const; 	///< See Compressor::threshold
  void                          threshold (double); 	///< See Compressor::threshold
  double                        ratio     () const; 	///< See Compressor::ratio
  void                          ratio     (double); 	///< See Compressor::ratio
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "threshold", &CompressorHandle::threshold, &CompressorHandle::threshold);
    __visitor_ (*this, "ratio", &CompressorHandle::ratio, &CompressorHandle::ratio);
  }
};
typedef CompressorHandle CompressorH; ///< Convenience alias for the IDL type Compressor.

class ClnT_RecordForGroups
{
public:
  /// @cond GeneratedFields
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  /// @endcond
  inline                        ClnT_RecordForGroups () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
  std::string                   __aida_type_name__ () const	{ return "BseTest::RecordForGroups"; }
  std::vector<std::string>      __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const ClnT_RecordForGroups &other) const;
  bool                          operator!=  (const ClnT_RecordForGroups &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (i, "i");
    _visitor_ (ratio, "ratio");
    _visitor_ (ordinary_bool, "ordinary_bool");
    _visitor_ (threshold1, "threshold1");
    _visitor_ (threshold2, "threshold2");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const ClnT_RecordForGroups&);
void operator>>= (Rapicorn::Aida::ProtoReader&, ClnT_RecordForGroups&);

/** @interface SoundModule
 * See also the corresponding C++ stub class SoundModuleHandle. */
/// See also the corresponding IDL class SoundModule.
class SoundModuleHandle : public virtual Rapicorn::Aida::RemoteHandle
{
  static SoundModuleHandle               __aida_cast__ (Rapicorn::Aida::RemoteHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  virtual /*Des*/                       ~SoundModuleHandle () override;
  template<class RemoteHandle>
  static SoundModuleHandle      down_cast (RemoteHandle smh) { return smh == NULL ? SoundModuleHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      SoundModuleHandle ();
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef SoundModuleHandle SoundModuleH; ///< Convenience alias for the IDL type SoundModule.
} // BseTest

// --- Implementations ---

namespace MandatoryNamespace {
FirstInterfaceHandle::FirstInterfaceHandle ()
{}
FirstInterfaceHandle::~FirstInterfaceHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
FirstInterfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x22113f623903ac14ULL, 0x3fe8e50c1a9a78d2ULL);
  return type_hash;
}
FirstInterfaceHandle
FirstInterfaceHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  FirstInterfaceHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
void
FirstInterfaceHandle::void_func () /// See FirstInterface::void_func()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 0), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xc3f858f5171056cbULL, 0x394e47a2bcd63e16ULL);
  fr = __o_.invoke (&__p_);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
std::vector<std::string>
ClnT_XFooRecord::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_XFooRecord::operator== (const ClnT_XFooRecord &other) const
{
  if (this->single_bool != other.single_bool) return false;
  if (this->single_num != other.single_num) return false;
  if (this->num64 != other.num64) return false;
  if (this->single_float != other.single_float) return false;
  if (this->single_string != other.single_string) return false;
  if (this->sibling1 != other.sibling1) return false;
  if (this->sibling2 != other.sibling2) return false;
  if (this->multi1 != other.multi1) return false;
  if (this->multi2 != other.multi2) return false;
  if (this->multi3 != other.multi3) return false;
  if (this->multi4 != other.multi4) return false;
  if (this->enum_field != other.enum_field) return false;
  if (this->iface1 != other.iface1) return false;
  if (this->iface2 != other.iface2) return false;
  if (this->iface3 != other.iface3) return false;
  if (this->any1 != other.any1) return false;
  if (this->any2 != other.any2) return false;
  if (this->any3 != other.any3) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_XFooRecord &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (18);
  __p_ <<= self.single_bool;
  __p_ <<= self.single_num;
  __p_ <<= self.num64;
  __p_ <<= self.single_float;
  __p_ <<= self.single_string;
  __p_ <<= self.sibling1;
  __p_ <<= self.sibling2;
  __p_ <<= self.multi1;
  __p_ <<= self.multi2;
  __p_ <<= self.multi3;
  __p_ <<= self.multi4;
  __p_ <<= self.enum_field;
  __p_ <<= self.iface1;
  __p_ <<= self.iface2;
  __p_ <<= self.iface3;
  __p_ <<= self.any1;
  __p_ <<= self.any2;
  __p_ <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_XFooRecord &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 18) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.num64;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
std::vector<std::string>
ClnT_XFooSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_XFooSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_XFooSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_IntSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_IntSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_IntSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_FloatSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_FloatSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_FloatSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_StringSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_StringSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_StringSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_ExtensiveEnumSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_ExtensiveEnumSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_ExtensiveEnumSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_RecordSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_RecordSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_RecordSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_SequenceSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_SequenceSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_SequenceSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_InterfaceSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_InterfaceSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_InterfaceSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_AnySequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_AnySequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_AnySequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_NestedTypesRec::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_NestedTypesRec::operator== (const ClnT_NestedTypesRec &other) const
{
  if (this->rec != other.rec) return false;
  if (this->seq != other.seq) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_NestedTypesRec &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (2);
  __p_ <<= self.rec;
  __p_ <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_NestedTypesRec &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
std::vector<std::string>
ClnT_NestedTypesSeq::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_NestedTypesSeq &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_NestedTypesSeq &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
std::vector<std::string>
ClnT_NewRecord::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_NewRecord::operator== (const ClnT_NewRecord &other) const
{
  if (this->i != other.i) return false;
  if (this->enum1 != other.enum1) return false;
  if (this->xfs != other.xfs) return false;
  if (this->ntr != other.ntr) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_NewRecord &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (4);
  __p_ <<= self.i;
  __p_ <<= self.enum1;
  __p_ <<= self.xfs;
  __p_ <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_NewRecord &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
std::vector<std::string>
ClnT_InnerRecord::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_InnerRecord::operator== (const ClnT_InnerRecord &other) const
{
  if (this->x != other.x) return false;
  if (this->y != other.y) return false;
  if (this->rec != other.rec) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_InnerRecord &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (3);
  __p_ <<= self.x;
  __p_ <<= self.y;
  __p_ <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_InnerRecord &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
std::vector<std::string>
ClnT_Refer2Inner::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_Refer2Inner::operator== (const ClnT_Refer2Inner &other) const
{
  if (this->r != other.r) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_Refer2Inner &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (1);
  __p_ <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_Refer2Inner &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
std::vector<std::string>
ClnT_SomeRecord::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_SomeRecord::operator== (const ClnT_SomeRecord &other) const
{
  if (this->r1 != other.r1) return false;
  if (this->r2 != other.r2) return false;
  if (this->r3 != other.r3) return false;
  if (this->r4 != other.r4) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_SomeRecord &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (4);
  __p_ <<= self.r1;
  __p_ <<= self.r2;
  __p_ <<= self.r3;
  __p_ <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_SomeRecord &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace Auxdata {
std::vector<std::string>
ClnT_RecordWithAuxdata::__aida_aux_data__  () const
{
  static const char __s_[] =
    "aux_bool.label=AuxBool\0"
    "aux_bool.blurb=A Boolean\0"
    "aux_bool.hints=rw\0"
    "aux_bool.default=0\0"
    "aux32.label=Aux32\0"
    "aux32.blurb=The Bar number\0"
    "aux32.hints=rw\0"
    "aux32.default=10007.0\0"
    "aux64.label=Aux64\0"
    "aux64.blurb=64bit auxillary number\0"
    "aux64.hints=rw\0"
    "aux64.default=1152921504606846976\0"
    "auxf64.label=AuxF64\0"
    "auxf64.blurb=X coordinate\0"
    "auxf64.hints=ro\0"
    "auxf64.default=0.019\0"
    "aux_str.label=AuxStr\0"
    "aux_str.blurb=Specify text here\0"
    "aux_str.hints=rw\0"
    "aux_str.default=auxtest3\0"
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_RecordWithAuxdata::operator== (const ClnT_RecordWithAuxdata &other) const
{
  if (this->aux_bool != other.aux_bool) return false;
  if (this->aux32 != other.aux32) return false;
  if (this->aux64 != other.aux64) return false;
  if (this->auxf64 != other.auxf64) return false;
  if (this->aux_str != other.aux_str) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_RecordWithAuxdata &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (5);
  __p_ <<= self.aux_bool;
  __p_ <<= self.aux32;
  __p_ <<= self.aux64;
  __p_ <<= self.auxf64;
  __p_ <<= self.aux_str;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_RecordWithAuxdata &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.aux_bool;
  fbr >>= self.aux32;
  fbr >>= self.aux64;
  fbr >>= self.auxf64;
  fbr >>= self.aux_str;
}
} // Auxdata

namespace InterfaceTests {
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__UIWidgetAreaHandle__void_signal (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
UIWidgetAreaHandle::__aida_connect__void_signal (size_t signal_handler_id, const std::function<void ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __o_.current_client_connection().signal_connect (0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL, *this, __aida_emit1__UIWidgetAreaHandle__void_signal, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__UIWidgetAreaHandle__sample_signal (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<double (UIWidgetAreaHandle &ba1, int someint)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  double rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
UIWidgetAreaHandle::__aida_connect__sample_signal (size_t signal_handler_id, const std::function<double (UIWidgetAreaHandle &ba1, int someint)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<double (UIWidgetAreaHandle &ba1, int someint)> (func);
  return __o_.current_client_connection().signal_connect (0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL, *this, __aida_emit2__UIWidgetAreaHandle__sample_signal, fptr);
}
UIWidgetAreaHandle::UIWidgetAreaHandle ()
{}
UIWidgetAreaHandle::~UIWidgetAreaHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
UIWidgetAreaHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x11db82aaba1ee248ULL, 0xd2359653ff87e972ULL);
  return type_hash;
}
UIWidgetAreaHandle
UIWidgetAreaHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  UIWidgetAreaHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
bool
UIWidgetAreaHandle::dummy () const /// See UIWidgetArea::dummy
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  bool  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::dummy (bool value) /// See UIWidgetArea::dummy
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x7aaf2f96f3042829ULL, 0x3d0391e5b72e7ba5ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
std::string
UIWidgetAreaHandle::on_click () const /// See UIWidgetArea::on_click
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::on_click (const std::string &value) /// See UIWidgetArea::on_click
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xf0025ec0fa66e3e2ULL, 0x880c10e8e6b57cfbULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
double
UIWidgetAreaHandle::simple_method () /// See UIWidgetArea::simple_method()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 0), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::single_arg (int arg_n) /// See UIWidgetArea::single_arg()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL);
  __p_ <<= arg_n;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::single_arg2 (int arg_n) /// See UIWidgetArea::single_arg2()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL);
  __p_ <<= arg_n;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::two_args (int arg_n,
                              double arg_r) /// See UIWidgetArea::two_args()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL);
  __p_ <<= arg_n;
  __p_ <<= arg_r;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::two_args2 (int arg_n,
                               double arg_r) /// See UIWidgetArea::two_args2()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL);
  __p_ <<= arg_n;
  __p_ <<= arg_r;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::multi_args (bool arg_b,
                                int64_t arg_n,
                                double arg_r,
                                int arg_i,
                                const std::string &arg_s,
                                double arg_y) /// See UIWidgetArea::multi_args()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 6), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL);
  __p_ <<= arg_b;
  __p_ <<= arg_n;
  __p_ <<= arg_r;
  __p_ <<= arg_i;
  __p_ <<= arg_s;
  __p_ <<= arg_y;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::self_method (UIWidgetAreaHandle &arg_ba1,
                                 UIWidgetAreaHandle &arg_ba2) /// See UIWidgetArea::self_method()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL);
  __p_ <<= arg_ba1;
  __p_ <<= arg_ba2;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::void_method () /// See UIWidgetArea::void_method()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 0), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xdbb304ad4df15873ULL, 0xca276abf2bb1603cULL);
  fr = __o_.invoke (&__p_);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
std::string
UIWidgetAreaHandle::on_click2out () /// See UIWidgetArea::on_click2out()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 0), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::on_click2in (const std::string &arg_command) /// See UIWidgetArea::on_click2in()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x3432c3bb41bc72a0ULL, 0x533bc22135f973bfULL);
  __p_ <<= arg_command;
  fr = __o_.invoke (&__p_);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
ParentHandle::ParentHandle ()
{}
ParentHandle::~ParentHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
ParentHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL);
  return type_hash;
}
ParentHandle
ParentHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  ParentHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
ChildHandle::ChildHandle ()
{}
ChildHandle::~ChildHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
ChildHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL);
  return type_hash;
}
ChildHandle
ChildHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  ChildHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
DescendantHandle::DescendantHandle ()
{}
DescendantHandle::~DescendantHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
DescendantHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL);
  return type_hash;
}
DescendantHandle
DescendantHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  DescendantHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
GrandChildHandle::GrandChildHandle ()
{}
GrandChildHandle::~GrandChildHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
GrandChildHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xf6975e5e92250718ULL, 0x53730d44919c46f9ULL);
  return type_hash;
}
GrandChildHandle
GrandChildHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  GrandChildHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
std::vector<std::string>
ClnT_QuickRecord::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_QuickRecord::operator== (const ClnT_QuickRecord &other) const
{
  if (this->int1 != other.int1) return false;
  if (this->int2 != other.int2) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_QuickRecord &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (2);
  __p_ <<= self.int1;
  __p_ <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_QuickRecord &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
std::vector<std::string>
ClnT_QuickSequence::__aida_aux_data__  () const
{
  static const char __s_[] =
    ""
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_QuickSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_QuickSequence &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
QuickIfaceHandle::QuickIfaceHandle ()
{}
QuickIfaceHandle::~QuickIfaceHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
QuickIfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x4524ee119d4e454cULL, 0xbeb61f7c3cc04f7dULL);
  return type_hash;
}
QuickIfaceHandle
QuickIfaceHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  QuickIfaceHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
void
QuickIfaceHandle::simple_function (int arg_i) /// See QuickIface::simple_function()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x76ac7a704663d246ULL, 0x23abac49621c6802ULL);
  __p_ <<= arg_i;
  fr = __o_.invoke (&__p_);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
MethodTestInterfaceHandle::MethodTestInterfaceHandle ()
{}
MethodTestInterfaceHandle::~MethodTestInterfaceHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
MethodTestInterfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x6bf684458ac5f01aULL, 0xf64c02611b807180ULL);
  return type_hash;
}
MethodTestInterfaceHandle
MethodTestInterfaceHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  MethodTestInterfaceHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
void
MethodTestInterfaceHandle::method_with_void () /// See MethodTestInterface::method_with_void()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 0), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x1addfccb0a3e01beULL, 0x314f2eb467d7a72bULL);
  fr = __o_.invoke (&__p_);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
bool
MethodTestInterfaceHandle::method_with_bools (bool arg_input,
                                              bool arg_optval) /// See MethodTestInterface::method_with_bools()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  bool  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
int
MethodTestInterfaceHandle::method_with_ints32 (int arg_input,
                                               int arg_optval) /// See MethodTestInterface::method_with_ints32()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  int  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
int64_t
MethodTestInterfaceHandle::method_with_ints64 (int64_t arg_input,
                                               int64_t arg_optval) /// See MethodTestInterface::method_with_ints64()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  int64_t  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
double
MethodTestInterfaceHandle::method_with_floats (double arg_input,
                                               double arg_optval) /// See MethodTestInterface::method_with_floats()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
std::string
MethodTestInterfaceHandle::method_with_string (const std::string &arg_input,
                                               const std::string &arg_optval) /// See MethodTestInterface::method_with_string()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
QuickEnum
MethodTestInterfaceHandle::method_with_enum (QuickEnum arg_input,
                                             QuickEnum arg_optval) /// See MethodTestInterface::method_with_enum()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  QuickEnum  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
ClnT_QuickRecord
MethodTestInterfaceHandle::method_with_record (const ClnT_QuickRecord &arg_input,
                                               const ClnT_QuickRecord &arg_optval) /// See MethodTestInterface::method_with_record()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  ClnT_QuickRecord  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
ClnT_QuickSequence
MethodTestInterfaceHandle::method_with_sequence (const ClnT_QuickSequence &arg_input,
                                                 const ClnT_QuickSequence &arg_optval) /// See MethodTestInterface::method_with_sequence()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  ClnT_QuickSequence  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
GrandChildHandle
MethodTestInterfaceHandle::method_with_interface (GrandChildHandle &arg_input,
                                                  GrandChildHandle &arg_optval) /// See MethodTestInterface::method_with_interface()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  GrandChildHandle  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
Rapicorn::Aida::Any
MethodTestInterfaceHandle::method_with_anys (const Rapicorn::Aida::Any &arg_input,
                                             const Rapicorn::Aida::Any &arg_optval) /// See MethodTestInterface::method_with_anys()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_optval;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  Rapicorn::Aida::Any  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
QuickIfaceHandle
MethodTestInterfaceHandle::method_with_quickiface (QuickIfaceHandle &arg_input,
                                                   QuickIfaceHandle &arg_iface0) /// See MethodTestInterface::method_with_quickiface()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 2), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL);
  __p_ <<= arg_input;
  __p_ <<= arg_iface0;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  QuickIfaceHandle  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__void_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__void_result (size_t signal_handler_id, const std::function<void ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __o_.current_client_connection().signal_connect (0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL, *this, __aida_emit1__SignalTestInterfaceHandle__void_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__bool_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<bool ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  bool rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__bool_result (size_t signal_handler_id, const std::function<bool ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<bool ()> (func);
  return __o_.current_client_connection().signal_connect (0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL, *this, __aida_emit2__SignalTestInterfaceHandle__bool_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__int32_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<int ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  int rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int32_result (size_t signal_handler_id, const std::function<int ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<int ()> (func);
  return __o_.current_client_connection().signal_connect (0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL, *this, __aida_emit2__SignalTestInterfaceHandle__int32_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__int64_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<int64_t ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  int64_t rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int64_result (size_t signal_handler_id, const std::function<int64_t ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<int64_t ()> (func);
  return __o_.current_client_connection().signal_connect (0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL, *this, __aida_emit2__SignalTestInterfaceHandle__int64_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__float64_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<double ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  double rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__float64_result (size_t signal_handler_id, const std::function<double ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<double ()> (func);
  return __o_.current_client_connection().signal_connect (0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL, *this, __aida_emit2__SignalTestInterfaceHandle__float64_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__string_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<std::string ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  std::string rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__string_result (size_t signal_handler_id, const std::function<std::string ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<std::string ()> (func);
  return __o_.current_client_connection().signal_connect (0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL, *this, __aida_emit2__SignalTestInterfaceHandle__string_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__enum_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<QuickEnum ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  QuickEnum rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__enum_result (size_t signal_handler_id, const std::function<QuickEnum ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<QuickEnum ()> (func);
  return __o_.current_client_connection().signal_connect (0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL, *this, __aida_emit2__SignalTestInterfaceHandle__enum_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__record_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<ClnT_QuickRecord ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  ClnT_QuickRecord rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__record_result (size_t signal_handler_id, const std::function<ClnT_QuickRecord ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<ClnT_QuickRecord ()> (func);
  return __o_.current_client_connection().signal_connect (0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL, *this, __aida_emit2__SignalTestInterfaceHandle__record_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__sequence_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<ClnT_QuickSequence ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  ClnT_QuickSequence rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__sequence_result (size_t signal_handler_id, const std::function<ClnT_QuickSequence ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<ClnT_QuickSequence ()> (func);
  return __o_.current_client_connection().signal_connect (0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL, *this, __aida_emit2__SignalTestInterfaceHandle__sequence_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__interface_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<GrandChildHandle ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  GrandChildHandle rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__interface_result (size_t signal_handler_id, const std::function<GrandChildHandle ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<GrandChildHandle ()> (func);
  return __o_.current_client_connection().signal_connect (0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL, *this, __aida_emit2__SignalTestInterfaceHandle__interface_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__any_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<Rapicorn::Aida::Any ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::Any rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x296163d4220985ceULL, 0x40daacab4a841093ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__any_result (size_t signal_handler_id, const std::function<Rapicorn::Aida::Any ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<Rapicorn::Aida::Any ()> (func);
  return __o_.current_client_connection().signal_connect (0x296163d4220985ceULL, 0x40daacab4a841093ULL, *this, __aida_emit2__SignalTestInterfaceHandle__any_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__SignalTestInterfaceHandle__self_result (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  SignalTestInterfaceHandle rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x35828273200534f7ULL, 0x72873f1374d6093bULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__self_result (size_t signal_handler_id, const std::function<SignalTestInterfaceHandle ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<SignalTestInterfaceHandle ()> (func);
  return __o_.current_client_connection().signal_connect (0x35828273200534f7ULL, 0x72873f1374d6093bULL, *this, __aida_emit2__SignalTestInterfaceHandle__self_result, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__void_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__void_arg (size_t signal_handler_id, const std::function<void ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __o_.current_client_connection().signal_connect (0xe79b3592345942f6ULL, 0x6818e92df5df5befULL, *this, __aida_emit1__SignalTestInterfaceHandle__void_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__bool_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (bool b)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__bool_arg (size_t signal_handler_id, const std::function<void (bool b)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (bool b)> (func);
  return __o_.current_client_connection().signal_connect (0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL, *this, __aida_emit1__SignalTestInterfaceHandle__bool_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__int32_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (int i)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int32_arg (size_t signal_handler_id, const std::function<void (int i)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (int i)> (func);
  return __o_.current_client_connection().signal_connect (0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL, *this, __aida_emit1__SignalTestInterfaceHandle__int32_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__int64_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (int64_t i)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int64_arg (size_t signal_handler_id, const std::function<void (int64_t i)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (int64_t i)> (func);
  return __o_.current_client_connection().signal_connect (0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL, *this, __aida_emit1__SignalTestInterfaceHandle__int64_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__float64_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (double f)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__float64_arg (size_t signal_handler_id, const std::function<void (double f)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (double f)> (func);
  return __o_.current_client_connection().signal_connect (0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL, *this, __aida_emit1__SignalTestInterfaceHandle__float64_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__string_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (const std::string &s)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__string_arg (size_t signal_handler_id, const std::function<void (const std::string &s)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const std::string &s)> (func);
  return __o_.current_client_connection().signal_connect (0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL, *this, __aida_emit1__SignalTestInterfaceHandle__string_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__enum_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (QuickEnum e)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__enum_arg (size_t signal_handler_id, const std::function<void (QuickEnum e)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (QuickEnum e)> (func);
  return __o_.current_client_connection().signal_connect (0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL, *this, __aida_emit1__SignalTestInterfaceHandle__enum_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__record_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (const ClnT_QuickRecord &r)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__record_arg (size_t signal_handler_id, const std::function<void (const ClnT_QuickRecord &r)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const ClnT_QuickRecord &r)> (func);
  return __o_.current_client_connection().signal_connect (0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL, *this, __aida_emit1__SignalTestInterfaceHandle__record_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__sequence_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (const ClnT_QuickSequence &s)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__sequence_arg (size_t signal_handler_id, const std::function<void (const ClnT_QuickSequence &s)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const ClnT_QuickSequence &s)> (func);
  return __o_.current_client_connection().signal_connect (0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL, *this, __aida_emit1__SignalTestInterfaceHandle__sequence_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__interface_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (GrandChildHandle &i)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__interface_arg (size_t signal_handler_id, const std::function<void (GrandChildHandle &i)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (GrandChildHandle &i)> (func);
  return __o_.current_client_connection().signal_connect (0xc2562bdab457affdULL, 0x189f1ba486f30579ULL, *this, __aida_emit1__SignalTestInterfaceHandle__interface_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__any_arg (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (const Rapicorn::Aida::Any &a)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__any_arg (size_t signal_handler_id, const std::function<void (const Rapicorn::Aida::Any &a)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const Rapicorn::Aida::Any &a)> (func);
  return __o_.current_client_connection().signal_connect (0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL, *this, __aida_emit1__SignalTestInterfaceHandle__any_arg, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__SignalTestInterfaceHandle__self_args (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (SignalTestInterfaceHandle &self_)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__self_args (size_t signal_handler_id, const std::function<void (SignalTestInterfaceHandle &self_)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (SignalTestInterfaceHandle &self_)> (func);
  return __o_.current_client_connection().signal_connect (0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL, *this, __aida_emit1__SignalTestInterfaceHandle__self_args, fptr);
}
SignalTestInterfaceHandle::SignalTestInterfaceHandle ()
{}
SignalTestInterfaceHandle::~SignalTestInterfaceHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
SignalTestInterfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL);
  return type_hash;
}
SignalTestInterfaceHandle
SignalTestInterfaceHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  SignalTestInterfaceHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__ChildInheritingSignalsHandle__child_signal (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const ClnT_QuickRecord &r, const ClnT_QuickSequence &s)>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
ChildInheritingSignalsHandle::__aida_connect__child_signal (size_t signal_handler_id, const std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const ClnT_QuickRecord &r, const ClnT_QuickSequence &s)> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const ClnT_QuickRecord &r, const ClnT_QuickSequence &s)> (func);
  return __o_.current_client_connection().signal_connect (0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL, *this, __aida_emit1__ChildInheritingSignalsHandle__child_signal, fptr);
}
ChildInheritingSignalsHandle::ChildInheritingSignalsHandle ()
{}
ChildInheritingSignalsHandle::~ChildInheritingSignalsHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
ChildInheritingSignalsHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xf20ff30241b5b694ULL, 0x9f544b2626e183f0ULL);
  return type_hash;
}
ChildInheritingSignalsHandle
ChildInheritingSignalsHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  ChildInheritingSignalsHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
AnotherChildHandle::AnotherChildHandle ()
{}
AnotherChildHandle::~AnotherChildHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
AnotherChildHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x9a33af1b27f7e36dULL, 0xdf625f7bd18934faULL);
  return type_hash;
}
AnotherChildHandle
AnotherChildHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  AnotherChildHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
PropertyTesterHandle::PropertyTesterHandle ()
{}
PropertyTesterHandle::~PropertyTesterHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
PropertyTesterHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xa37ab462c55a3b3cULL, 0x4f3fd1c9ad9689fbULL);
  return type_hash;
}
PropertyTesterHandle
PropertyTesterHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  PropertyTesterHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
bool
PropertyTesterHandle::bool_prop () const /// See PropertyTester::bool_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  bool  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::bool_prop (bool value) /// See PropertyTester::bool_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xa88d7a16adc7ad43ULL, 0x33e7a32598f08880ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
int
PropertyTesterHandle::int32_prop () const /// See PropertyTester::int32_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  int  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::int32_prop (int value) /// See PropertyTester::int32_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x7b7b3182160469e4ULL, 0xbd3c44c3a57484ebULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
int64_t
PropertyTesterHandle::int64_prop () const /// See PropertyTester::int64_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  int64_t  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::int64_prop (int64_t value) /// See PropertyTester::int64_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xb33bf89d2259a1dbULL, 0x0154420aebe9a16cULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
double
PropertyTesterHandle::float64_prop () const /// See PropertyTester::float64_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::float64_prop (double value) /// See PropertyTester::float64_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xf1df5bd296ac78e2ULL, 0xbb263cff89927093ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
std::string
PropertyTesterHandle::string_prop () const /// See PropertyTester::string_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::string_prop (const std::string &value) /// See PropertyTester::string_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xfadb1eed1d8d358aULL, 0x17cd2ca684080698ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
QuickEnum
PropertyTesterHandle::enum_prop () const /// See PropertyTester::enum_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  QuickEnum  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::enum_prop (QuickEnum value) /// See PropertyTester::enum_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x99206fff699c82d6ULL, 0x1dcbc77498569411ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
ClnT_QuickRecord
PropertyTesterHandle::record_prop () const /// See PropertyTester::record_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  ClnT_QuickRecord  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::record_prop (const ClnT_QuickRecord &value) /// See PropertyTester::record_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x55aaf8cee9dd7a46ULL, 0x83d8416416740bf0ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
ClnT_QuickSequence
PropertyTesterHandle::sequence_prop () const /// See PropertyTester::sequence_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  ClnT_QuickSequence  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::sequence_prop (const ClnT_QuickSequence &value) /// See PropertyTester::sequence_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xf86952a034b8bc84ULL, 0x3be169a3f0a9a07dULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
GrandChildHandle
PropertyTesterHandle::interface_prop () const /// See PropertyTester::interface_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  GrandChildHandle  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::interface_prop (GrandChildHandle value) /// See PropertyTester::interface_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xbf62779e2a11aebbULL, 0x95547f4e29ca3814ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
PropertyTesterHandle
PropertyTesterHandle::self_prop () const /// See PropertyTester::self_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  PropertyTesterHandle  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::self_prop (PropertyTesterHandle value) /// See PropertyTester::self_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x1a1ee3ab20ab3c2fULL, 0xeeaf17826dba2891ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
Rapicorn::Aida::Any
PropertyTesterHandle::any_prop () const /// See PropertyTester::any_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  Rapicorn::Aida::Any  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::any_prop (const Rapicorn::Aida::Any &value) /// See PropertyTester::any_prop
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xe0c7d397e652f3f7ULL, 0xbbdf7826e88f4f42ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
} // InterfaceTests

namespace RapicornAidaTest {
UseIncludesHandle::UseIncludesHandle ()
{}
UseIncludesHandle::~UseIncludesHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
UseIncludesHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xfbdf1e0d7f39f4f0ULL, 0x78270f907e3216b4ULL);
  return type_hash;
}
UseIncludesHandle
UseIncludesHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  UseIncludesHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit2__ButtonAreaHandle__check_activate (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<bool ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  bool rval = Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::ProtoMsg &rb = *__AIDA_Local__::new_emit_result (sfb, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
ButtonAreaHandle::__aida_connect__check_activate (size_t signal_handler_id, const std::function<bool ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<bool ()> (func);
  return __o_.current_client_connection().signal_connect (0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL, *this, __aida_emit2__ButtonAreaHandle__check_activate, fptr);
}
static Rapicorn::Aida::ProtoMsg*
__aida_emit1__ButtonAreaHandle__activate (const Rapicorn::Aida::ProtoMsg *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) // disconnect signal
    {
      delete fptr;
      return NULL;
    }
  Rapicorn::Aida::uint64 emit_result_id;
  assert (NULL != &Rapicorn::Aida::ProtoScope::current_client_connection());
  Rapicorn::Aida::proto_msg_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
ButtonAreaHandle::__aida_connect__activate (size_t signal_handler_id, const std::function<void ()> &func)
{
  Rapicorn::Aida::ProtoScope __o_ (*__aida_connection__());
  if (signal_handler_id)
    return __o_.current_client_connection().signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __o_.current_client_connection().signal_connect (0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL, *this, __aida_emit1__ButtonAreaHandle__activate, fptr);
}
ButtonAreaHandle::ButtonAreaHandle ()
{}
ButtonAreaHandle::~ButtonAreaHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
ButtonAreaHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xec371b296fa57436ULL, 0x92e4310e386fc92eULL);
  return type_hash;
}
ButtonAreaHandle
ButtonAreaHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  ButtonAreaHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
std::string
ButtonAreaHandle::on_click () const /// See ButtonArea::on_click
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click (const std::string &value) /// See ButtonArea::on_click
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xdb3a24116c653985ULL, 0x2a0576faff45b4b2ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
std::string
ButtonAreaHandle::on_click2 () const /// See ButtonArea::on_click2
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x1b448d91990181daULL, 0x9751c08ae956c729ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click2 (const std::string &value) /// See ButtonArea::on_click2
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xfc93898ba4104662ULL, 0xc918694fe5c2bfefULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
std::string
ButtonAreaHandle::on_click3 () const /// See ButtonArea::on_click3
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  std::string  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click3 (const std::string &value) /// See ButtonArea::on_click3
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x1c1990dca0fde97cULL, 0x6cc2c7cc49d811f8ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
ClickType
ButtonAreaHandle::click_type () const /// See ButtonArea::click_type
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  ClickType  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::click_type (ClickType value) /// See ButtonArea::click_type
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x1f5a6d031cb7e104ULL, 0x2d4a207f0842bec8ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
PureMethodsHandle::PureMethodsHandle ()
{}
PureMethodsHandle::~PureMethodsHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
PureMethodsHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xddc2a514d04d3af5ULL, 0xc0046740434c0486ULL);
  return type_hash;
}
PureMethodsHandle
PureMethodsHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  PureMethodsHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
int
PureMethodsHandle::pure_method (double arg_f) /// See PureMethods::pure_method()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL);
  __p_ <<= arg_f;
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  int  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
} // RapicornAidaTest

namespace Other {
NameTestsHandle::NameTestsHandle ()
{}
NameTestsHandle::~NameTestsHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
NameTestsHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x542d40cd7d8fcd40ULL, 0x8c1782df29c9b936ULL);
  return type_hash;
}
NameTestsHandle
NameTestsHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  NameTestsHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
void
NameTestsHandle::args_from_other_namespace (const InterfaceTests::ClnT_QuickRecord &arg_qr,
                                            RapicornAidaTest::ClickType arg_qe,
                                            const OtherNamespace::ClnT_SomeRecord &arg_sr) /// See NameTests::args_from_other_namespace()
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 3), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xd471f88e8c15081cULL, 0x963d2094339d0220ULL);
  __p_ <<= arg_qr;
  __p_ <<= arg_qe;
  __p_ <<= arg_sr;
  fr = __o_.invoke (&__p_);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
} // Other

namespace BseTest {
CompressorHandle::CompressorHandle ()
{}
CompressorHandle::~CompressorHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
CompressorHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x42057a05d51182dfULL, 0x6a0d69cda274433eULL);
  return type_hash;
}
CompressorHandle
CompressorHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  CompressorHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
double
CompressorHandle::threshold () const /// See Compressor::threshold
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
CompressorHandle::threshold (double value) /// See Compressor::threshold
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0xf40a3fd3d07b3d0bULL, 0xbae97c41e3d6a92bULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
double
CompressorHandle::ratio () const /// See Compressor::ratio
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall2Way __o_ (__p_, *this, 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL);
  fr = __o_.invoke (&__p_);
  Rapicorn::Aida::ProtoReader __f_ (*fr);
  __f_.skip_header();
  double  retval;
  __f_ >>= retval;
  delete fr;
  return retval;
}
void
CompressorHandle::ratio (double value) /// See Compressor::ratio
{
  Rapicorn::Aida::ProtoMsg &__p_ = *Rapicorn::Aida::ProtoMsg::_new (3 + 1 + 1), *fr = NULL;
  Rapicorn::Aida::ProtoScopeCall1Way __o_ (__p_, *this, 0x302f0b5b99a2a6c8ULL, 0xc8b771894ecd9315ULL);
  __p_ <<= value;
  fr = __o_.invoke (&__p_);
  if (fr) delete fr;
}
std::vector<std::string>
ClnT_RecordForGroups::__aida_aux_data__  () const
{
  static const char __s_[] =
    "ratio.hints=w\0"
    "ratio.default=0\0"
    "ratio.group=Normal\0"
  ;
  static const std::vector<std::string> __d_ =
    ::Rapicorn::Aida::aux_vectors_combine (__s_, sizeof (__s_));
  return __d_;
}
bool
ClnT_RecordForGroups::operator== (const ClnT_RecordForGroups &other) const
{
  if (this->i != other.i) return false;
  if (this->ratio != other.ratio) return false;
  if (this->ordinary_bool != other.ordinary_bool) return false;
  if (this->threshold1 != other.threshold1) return false;
  if (this->threshold2 != other.threshold2) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::ProtoMsg &dst, const ClnT_RecordForGroups &self)
{
  Rapicorn::Aida::ProtoMsg &__p_ = dst.add_rec (5);
  __p_ <<= self.i;
  __p_ <<= self.ratio;
  __p_ <<= self.ordinary_bool;
  __p_ <<= self.threshold1;
  __p_ <<= self.threshold2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::ProtoReader &src, ClnT_RecordForGroups &self)
{
  Rapicorn::Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.i;
  fbr >>= self.ratio;
  fbr >>= self.ordinary_bool;
  fbr >>= self.threshold1;
  fbr >>= self.threshold2;
}
SoundModuleHandle::SoundModuleHandle ()
{}
SoundModuleHandle::~SoundModuleHandle ()
{} // define empty dtor to emit vtable
const Rapicorn::Aida::TypeHash&
SoundModuleHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x06447b38b51e0198ULL, 0x848669199cc311deULL);
  return type_hash;
}
SoundModuleHandle
SoundModuleHandle::__aida_cast__ (Rapicorn::Aida::RemoteHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  SoundModuleHandle target;
  for (size_t i = 0; i < types.size(); i++)
    if (mine == types[i]) {
      target.__aida_upgrade_from__ (other);
      break;
    }
  return target;
}
} // BseTest

#if     __ENUMCC__tests_t301_testpass_idl__ == 1

namespace Rapicorn {

namespace Aida {

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum1> ()
{
  static const EnumValue _aida_enumvalues_1001[] = {
    { int64_t (MandatoryNamespace::Enum1::E1_A), "E1_A", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum1", 0, _aida_enumvalues_1001);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum1> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum1c> ()
{
  static const EnumValue _aida_enumvalues_1002[] = {
    { int64_t (MandatoryNamespace::Enum1c::E1C_A), "E1C_A", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum1c", 0, _aida_enumvalues_1002);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum1c> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum2> ()
{
  static const EnumValue _aida_enumvalues_1003[] = {
    { int64_t (MandatoryNamespace::Enum2::E2_A), "E2_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum2::E2_B), "E2_B", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum2", 0, _aida_enumvalues_1003);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum2> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum2c> ()
{
  static const EnumValue _aida_enumvalues_1004[] = {
    { int64_t (MandatoryNamespace::Enum2c::E2C_A), "E2C_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum2c::E2C_B), "E2C_B", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum2c", 0, _aida_enumvalues_1004);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum2c> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum3> ()
{
  static const EnumValue _aida_enumvalues_1005[] = {
    { int64_t (MandatoryNamespace::Enum3::E3_A), "E3_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3::E3_B), "E3_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3::E3_C), "E3_C", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum3", 0, _aida_enumvalues_1005);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum3> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum3c> ()
{
  static const EnumValue _aida_enumvalues_1006[] = {
    { int64_t (MandatoryNamespace::Enum3c::E3C_A), "E3C_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3c::E3C_B), "E3C_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3c::E3C_C), "E3C_C", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum3c", 0, _aida_enumvalues_1006);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum3c> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4a> ()
{
  static const EnumValue _aida_enumvalues_1007[] = {
    { int64_t (MandatoryNamespace::Enum4a::E4A_A), "E4A_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4a::E4A_B), "E4A_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4a::E4A_C), "E4A_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4a::E4A_D), "E4A_D", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4a", 0, _aida_enumvalues_1007);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4a> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4b> ()
{
  static const EnumValue _aida_enumvalues_1008[] = {
    { int64_t (MandatoryNamespace::Enum4b::E4B_A), "E4B_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4b::E4B_B), "E4B_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4b::E4B_C), "E4B_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4b::E4B_D), "E4B_D", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4b", 0, _aida_enumvalues_1008);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4b> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4c> ()
{
  static const EnumValue _aida_enumvalues_1009[] = {
    { int64_t (MandatoryNamespace::Enum4c::E4C_A), "E4C_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4c::E4C_B), "E4C_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4c::E4C_C), "E4C_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4c::E4C_D), "E4C_D", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4c", 0, _aida_enumvalues_1009);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4c> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4d> ()
{
  static const EnumValue _aida_enumvalues_1010[] = {
    { int64_t (MandatoryNamespace::Enum4d::E4D_A), "E4D_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4d::E4D_B), "E4D_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4d::E4D_C), "E4D_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4d::E4D_D), "E4D_D", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4d", 0, _aida_enumvalues_1010);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4d> (); // instantiation

template<> const EnumInfo&
enum_info<MandatoryNamespace::ExtensiveEnum> ()
{
  static const EnumValue _aida_enumvalues_1011[] = {
    { int64_t (MandatoryNamespace::ExtensiveEnum::V1a), "V1a", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V1b), "V1b", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V2), "V2", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V3), "V3", "v3", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V4), "V4", _("v4"), NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V5), "V5", "v5", "V5" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V6), "V6", _("v6"), "V6" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V7), "V7", "v7", _("V7") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V8), "V8", _("v8"), _("V8") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V9), "V9", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V10), "V10", "v10", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V11), "V11", _("v11"), NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V12), "V12", "v12", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V13), "V13", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V14), "V14", _("v14"), NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V15), "V15", "v15", "V15" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V16), "V16", _("v16"), "V16" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V17), "V17", "v17", _("V17") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V18), "V18", _("v18"), _("V18") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V20), "V20", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V21), "V21", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V22), "V22", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V23), "V23", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V24), "V24", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V25), "V25", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V26), "V26", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V27), "V27", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V28), "V28", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V30), "V30", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V31), "V31", "foo", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V32), "V32", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V33), "V33", "foo", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V34), "V34", "foo", "foo" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V35), "V35", "foo", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V36), "V36", "foo", "foo""4" },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::ExtensiveEnum", 0, _aida_enumvalues_1011);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::ExtensiveEnum> (); // instantiation

template<> const EnumInfo&
enum_info<InterfaceTests::QuickEnum> ()
{
  static const EnumValue _aida_enumvalues_1012[] = {
    { int64_t (InterfaceTests::QuickEnum::ZERO), "ZERO", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("InterfaceTests::QuickEnum", 0, _aida_enumvalues_1012);
} // specialization
template const EnumInfo& enum_info<InterfaceTests::QuickEnum> (); // instantiation

template<> const EnumInfo&
enum_info<RapicornAidaTest::ClickType> ()
{
  static const EnumValue _aida_enumvalues_1013[] = {
    { int64_t (RapicornAidaTest::ClickType::CLICK_ON_PRESS), "CLICK_ON_PRESS", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_ON_RELEASE), "CLICK_ON_RELEASE", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_SLOW_REPEAT), "CLICK_SLOW_REPEAT", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_FAST_REPEAT), "CLICK_FAST_REPEAT", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_KEY_REPEAT), "CLICK_KEY_REPEAT", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("RapicornAidaTest::ClickType", 0, _aida_enumvalues_1013);
} // specialization
template const EnumInfo& enum_info<RapicornAidaTest::ClickType> (); // instantiation

template<> const EnumInfo&
enum_info<RapicornAidaTest::MathExpressions> ()
{
  static const EnumValue _aida_enumvalues_1014[] = {
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_2), "RESULT_2", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_5), "RESULT_5", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_8), "RESULT_8", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_6), "RESULT_6", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_7), "RESULT_7", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_16), "RESULT_16", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_3), "RESULT_3", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_24), "RESULT_24", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_13), "RESULT_13", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_m2), "RESULT_m2", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_77), "RESULT_77", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_511), "RESULT_511", NULL, NULL },
  };
  return ::Rapicorn::Aida::EnumInfo::cached_enum_info ("RapicornAidaTest::MathExpressions", 0, _aida_enumvalues_1014);
} // specialization
template const EnumInfo& enum_info<RapicornAidaTest::MathExpressions> (); // instantiation
} // Aida
} // Rapicorn

#endif // __ENUMCC__tests_t301_testpass_idl__

#endif /* __CLNT__tests_t301_testpass_idl */
